'use strict';

exports.__esModule = true;
exports.getStyles = getStyles;
exports.createSerializer = createSerializer;

var _css = require('css');

var css = _interopRequireWildcard(_css);

var _replaceClassNames = require('./replace-class-names');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function getNodes(node) {
  var nodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (node.children) {
    node.children.forEach(function (child) {
      return getNodes(child, nodes);
    });
  }

  if (typeof node === 'object') {
    nodes.push(node);
  }

  return nodes;
}

function getSelectors(nodes) {
  return nodes.reduce(function (selectors, node) {
    return getSelectorsFromProps(selectors, node.props);
  }, []);
}

function getSelectorsFromProps(selectors, props) {
  var className = props.className || props.class;
  if (className) {
    selectors = selectors.concat(className.split(' ').map(function (cn) {
      return '.' + cn;
    }));
  }
  return selectors;
}

function filterChildSelector(baseSelector) {
  if (baseSelector.slice(-1) === '>') {
    return baseSelector.slice(0, -1);
  }
  return baseSelector;
}

function getStyles(emotion) {
  return Object.keys(emotion.caches.inserted).reduce(function (style, current) {
    if (emotion.caches.inserted[current] === true) {
      return style;
    }
    return style + emotion.caches.inserted[current];
  }, '');
}

function test(val) {
  return val && !val.withEmotionStyles && val.$$typeof === Symbol.for('react.test.json');
}

function createSerializer(emotion) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      classNameReplacer = _ref.classNameReplacer;

  function print(val, printer) {
    var nodes = getNodes(val);
    markNodes(nodes);
    var selectors = getSelectors(nodes);
    var styles = getStylesFromSelectors(selectors);
    var printedVal = printer(val);
    return (0, _replaceClassNames.replaceClassNames)(selectors, styles, printedVal, emotion.caches.key, classNameReplacer);
  }

  function markNodes(nodes) {
    nodes.forEach(function (node) {
      node.withEmotionStyles = true;
    });
  }

  function getStylesFromSelectors(nodeSelectors) {
    var styles = getStyles(emotion);
    var ast = void 0;
    try {
      ast = css.parse(styles);
    } catch (e) {
      console.error(e);
      throw new Error('There was an error parsing css in jest-emotion-react: "' + styles + '"');
    }
    ast.stylesheet.rules = ast.stylesheet.rules.reduce(reduceRules, []);

    var ret = css.stringify(ast);
    return ret;

    function reduceRules(rules, rule) {
      var shouldIncludeRule = false;
      if (rule.type === 'rule') {
        shouldIncludeRule = rule.selectors.some(function (selector) {
          var baseSelector = filterChildSelector(selector.split(/:| |\./).filter(function (s) {
            return !!s;
          })[0]);
          return nodeSelectors.some(function (sel) {
            return sel === baseSelector || sel === '.' + baseSelector;
          });
        });
      }
      if (rule.type === 'media' || rule.type === 'supports') {
        rule.rules = rule.rules.reduce(reduceRules, []);

        if (rule.rules.length) {
          shouldIncludeRule = true;
        }
      }
      return shouldIncludeRule ? rules.concat(rule) : rules;
    }
  }

  return { test: test, print: print };
}