"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var check_node_1 = require("./shared/check-node");
var Ignore = require("./shared/ignore");
// tslint:disable-next-line:variable-name
exports.Rule = check_node_1.createCheckNodeRule(checkNode, "Using expressions to cause side-effects not allowed.");
function checkNode(node, ctx) {
    if (node && node.kind === ts.SyntaxKind.ExpressionStatement) {
        var esNode = node;
        var children = esNode.getChildren();
        var isYield = children.every(function (n) { return n.kind === ts.SyntaxKind.YieldExpression; });
        var text = esNode.getText(esNode.getSourceFile());
        if (esNode.expression.kind === ts.SyntaxKind.AwaitExpression) {
            var awaitNode = esNode.expression;
            text = awaitNode.expression.getText(awaitNode.getSourceFile());
        }
        var isIgnored2 = Ignore.isIgnoredPrefix(text, ctx.options.ignorePrefix);
        if (!isYield && !isIgnored2) {
            return { invalidNodes: [check_node_1.createInvalidNode(esNode, [])] };
        }
    }
    return { invalidNodes: [] };
}
//# sourceMappingURL=noExpressionStatementRule.js.map