"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var Lint = require("tslint");
var Ignore = require("./shared/ignore");
var check_node_1 = require("./shared/check-node");
// tslint:disable-next-line:variable-name
exports.Rule = check_node_1.createCheckNodeRule(Ignore.checkNodeWithIgnore(checkNode), "Only ReadonlyArray allowed.");
function checkNode(node, ctx) {
    return {
        invalidNodes: checkArrayType(node, ctx).concat(checkTypeReference(node, ctx), checkVariableOrParameterImplicitType(node, ctx))
    };
}
function checkArrayType(node, ctx) {
    // We need to check both shorthand syntax "number[]"...
    if (node.kind === ts.SyntaxKind.ArrayType) {
        if (node.parent &&
            Ignore.shouldIgnorePrefix(node.parent, ctx.options, ctx.sourceFile)) {
            return [];
        }
        return [
            check_node_1.createInvalidNode(node, [
                new Lint.Replacement(node.getStart(ctx.sourceFile), 0, "ReadonlyArray<"),
                new Lint.Replacement(node.end - 2, 2, ">")
            ])
        ];
    }
    return [];
}
function checkTypeReference(node, ctx) {
    // ...and type reference "Array<number>"
    if (node.kind === ts.SyntaxKind.TypeReference &&
        node.typeName.getText(ctx.sourceFile) === "Array") {
        if (node.parent &&
            Ignore.shouldIgnorePrefix(node.parent, ctx.options, ctx.sourceFile)) {
            return [];
        }
        return [
            check_node_1.createInvalidNode(node, [
                new Lint.Replacement(node.getStart(ctx.sourceFile), 0, "Readonly")
            ])
        ];
    }
    return [];
}
function checkVariableOrParameterImplicitType(node, ctx) {
    if (node.kind === ts.SyntaxKind.VariableDeclaration ||
        node.kind === ts.SyntaxKind.Parameter ||
        node.kind === ts.SyntaxKind.PropertyDeclaration) {
        // The initializer is used to set and implicit type
        var varOrParamNode = node;
        if (Ignore.shouldIgnorePrefix(node, ctx.options, ctx.sourceFile)) {
            return [];
        }
        if (!varOrParamNode.type) {
            if (varOrParamNode.initializer &&
                varOrParamNode.initializer.kind === ts.SyntaxKind.ArrayLiteralExpression) {
                var length_1 = varOrParamNode.name.getWidth(ctx.sourceFile);
                var nameText = varOrParamNode.name.getText(ctx.sourceFile);
                var typeArgument = "any";
                // Not sure it is a good idea to guess what the element types are...
                // const arrayLiteralNode = varOrParamNode.initializer as ts.ArrayLiteralExpression;
                // if (arrayLiteralNode.elements.length > 0) {
                //   const element = arrayLiteralNode.elements[0];
                //   if (element.kind === ts.SyntaxKind.NumericLiteral) {
                //     typeArgument = "number";
                //   } else if (element.kind === ts.SyntaxKind.StringLiteral) {
                //     typeArgument = "string";
                //   } else if (element.kind === ts.SyntaxKind.TrueKeyword || element.kind === ts.SyntaxKind.FalseKeyword) {
                //     typeArgument = "boolean";
                //   }
                // }
                return [
                    check_node_1.createInvalidNode(varOrParamNode.name, [
                        new Lint.Replacement(varOrParamNode.name.end - length_1, length_1, nameText + ": ReadonlyArray<" + typeArgument + ">")
                    ])
                ];
            }
        }
    }
    return [];
}
//# sourceMappingURL=readonlyArrayRule.js.map